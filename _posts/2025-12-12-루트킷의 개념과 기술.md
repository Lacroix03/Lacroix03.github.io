---
title: "루트킷의 개념과 기술"
date: "2025-12-12 3:11:00 +0900"
categories:
  - Security
tags:
  - Malware, Rootkit
toc: true
toc_sticky: true
render_with_liquid: false
published: true
---

요즘 악성코드 분석을 하다보니 윈도우 운영체제에 대한 깊은 이해가 필요하다는 것을 더더욱 느끼고 있다.

그래서 [루트킷: 윈도우 커널 조작의 미학]이라는 책을 베이스로 루트킷 공부 겸 윈도우 커널 쪽을 공부해보려고 한다.

좀 옛날 책이긴 하지만 그래도 루트킷과 커널에 대한 기본 지식을 쌓기엔 충분할 것 같다.    

## 루트킷이란?

공격자가 컴퓨터의 관리자 계정인 “root” 계정의 권한을 획득하는 데 유용하게 사용되는 작은 프로그램들로 이루어진 “kit”이라고 할 수 있다. 루트킷은 영구적 또는 일관적으로 탐지되지 않는 형태로 컴퓨터에 존재할 수 있게 해주는 프로그램들과 코드들로 이루어져 있는데, 여기서 핵심적인 키워드는 “탐지되지 않는”이다.

## 루트킷의 동작

소프트웨어를 간단히 말하면 특정한 데이터의 값을 기준으로 특정한 판단을 내리도록 설계된다. 루트킷은 이러한 소프트웨어의 판단 로직을 변경해 잘못된 판단을 내리도록 만든다.

대표적인 조작 방식은 아래와 같다.

### 1) 코드 패치(Patching)

코드 바이트를 직접 수정해 원래 기능을 변경하거나 우회한다.

### 2) 함수 후킹(Hooking)

테이블(IAT/SSDT/HAL) 또는 inline hook으로 호출 흐름을 가로챈다.

### 3) 감염 기반 오염(Infection)

다른 소프트웨어를 감염시켜 악성 로직을 끼워 넣는다.

### 4) 공급망 오염(Supply Chain)

오픈소스 또는 빌드 과정에서 악성 코드가 혼입된다.

그리고 루트킷은 ‘공격 도구’라기보다, 공격을 **보조하는 유틸리티**라는 점이 중요하다.

루트킷 자체는 공격 기능을 갖지 않아도 되며, 탐지 회피와 은닉만 잘하면 된다.

추가로, 루트킷은 공격툴이 아니다. 공격 코드와 결합되어 사용되기는 하지만, 루트킷 자체는 명백한 유틸리티 프로그램 이다. 일반적으로 루트킷은 커널에 대한 접근 권한이 필요하며 시스템이 부팅될 때 실행되는 하나 이상의 프로그램을 포함한다. 커널에 접근하는 방법은 한정되어 있으며, 이런 방법들을 이용하는 것은 침해 대응 차원에서 탐지될 수 있다.

그래서 루트킷을 설치하는 새로운 방법으로 소프트웨어 공격 코드를 이용하는 방법이 있다. 커널에 임의 코드를 실행시킬 수 있는 취약점이 있다면 시스템이 시작할 때 로더 프로그램이 해당 취약점을 이용해 루트킷을 로드할 수 있다. 이러한 방법을 사용하면 공개된 취약점이 아니기 때문에 침해 대응 조사에서도 조사의 대상이 되지 않고, 호스트 기반 방화벽 프로그램에 의해서도 방어되지 않는다. 

## 커널 접근과 최신 루트킷 트렌드

예전에는 루트킷이 커널 드라이버(.sys)를 로드하거나 SSDT(사용자 모드에서 커널 모드로 진입할 때 쓰이는 시스템 콜 주소 테이블) 패치를 통해 실행되었지만,

**Windows Vista 이후 Kernel Patch Protection(KPP/ PatchGuard :** SSDT 엔트리가 변경되면 즉시 BSOD로 차단됨)**,** Driver Signature Enforcement(DSE : 드라이버 사인 강제로 임의 드라이버 로딩을 매우 어렵게 함)가 적용되면서 어려워졌다.

그래서 최근 루트킷은 아래 방식으로 진화했다.

### 최신 루트킷 트렌드

- **BYOVD(Bring Your Own Vulnerable Driver)**
    
    취약한 정식 서명 드라이버를 로드하여 커널 권한을 얻는 방식.
    
    최근 수년간 가장 유행하는 루트킷 기법.
    
- **ETW(SYSTEM) 및 AMSI 우회**
    
    탐지 기반 메커니즘(ETW-TI, AMSI Patch)을 무력화해 사용자 모드 루트킷처럼 동작.
    
- **UEFI 루트킷**
    
    OS 이전 단계에 상주하여 사실상 제거가 불가능한 수준.
    
- **Hypervisor-level Rootkit(Virtualization-based Rootkit)**
    
    Blue Pill처럼 하이퍼바이저 아래에 숨어 OS 전체를 감시.
    
- **커널 콜백/오브젝트 필터 조작**
    
    PsSetCreateProcessNotifyRoutine 등 콜백 후킹으로 보안 제품 눈 가리기.
    
- **EDR 우회 전문화**
    
    EDR의 API 모니터링, syscall filtering, handle filtering 등을 무력화하는 기술 등장.
    

즉, **예전 SSDT 패치 중심의 루트킷은 거의 사라졌고**, 지금은 보안 제품을 우회하는 정교한 트릭 중심으로 발전했다.

## 탐지되지 않기 위한 루트킷 기술

성능이 좋은 루트킷은 방화벽이나 침입 탐지시스템(IDS)같은 각종 보안 대책을 우회해서 통과할 수 있어야 한다.

루트킷이 피해야 할 침입 탐지 시스템은 크게 두가지이다.

- **NIDS(Network IDS)**
- **HIDS/HIPS(Host IDS/IPS)**

대부분의 루트킷이 위협이라고 보는 대상은 HIPS이고, 대부분의 HIPS는 커널 레벨의 기술을 이용하며 운영체제에 대한 모니터링을 수행할 수 있으므로 안티루트킷이라고 말할 수 있다. 

루트킷은 이를 피하기 위해 아래와 같은 방식을 사용한다.

### 1. 적극적 우회(Active Evasion)

- 보안 도구의 드라이버 로직을 패치
- 커널 옵젝(EPROCESS, DRIVER_OBJECT, HANDLE TABLE) 은닉
- 시스템 콜 후킹/우회
- ETW/AMSI 기능 비활성화
- Callback 제거 및 우회

HIPS 무력화를 위해서는 대부분 이러한 적극적 기법이 필요하다.

### 2. 소극적 우회(Passive Evasion)

- 데이터 암호화
- 패턴 없는 스테가노그래피 저장
- 은닉 채널(Covert Channel) 활용
    
    → 정상 트래픽에 섞어 명령을 전달
    

포렌식 스캐너(EnCase 등)의 바이트 단위 검색을 피하기 위해

암호화 또는 난독화된 저장 방식이 자주 사용된다.

(단, 높은 엔트로피는 또 다른 탐지 포인트가 되기 때문에 폴리모픽·메타모픽 변형이 함께 사용되기도 함.)

## EDR(EPP/EDR) 우회 기술

- Sysmon 로그 차단 또는 파괴
    
    → 커널 드라이버(sysmon.sys) + 서비스(sysmon.exe)조합으로 프로세스 생성/종료, 네트워크 연결, 이미지 로드 등의이벤트를 ETW + 커널콜백을 통해 캡처하고, Window Event Log에 기록. 이 때 event log API를 후킹하거나, Sysmon 드라이버의 콜백 함수 포인터를 찾아 NOP처리하는 방법 등을 통해 로그를 차단하거나 파괴할 수 있다.  
    
- ETW TI(Event Tracing for Windows Threat Intelligence) 비활성화
    
    → ETW(Windows 이벤트 트레이싱) 중에서도 TI(Threat Intelligence) provider는 스크립트 실행, AMSI 이벤트, 프로세스/모듈 로딩, 보안 관련 컨텍스트 등을 굉장히 자세히 로깅해서, EDR/Defender 같은 애들이 행위 기반 탐지를 할 수 있게 해주는데, ETW관련 API를 후킹하거나 ETW registration table에 있는 ThreatIntelligence provider를 찾아 비활성화하는 방법 등을 사용할 수 있다.
    
- ObRegisterCallbacks 조작
    
    → ObRegisterCallbacks는 커널에서 핸들 생성/복사 시점에 개입할 수 있는 메커니즘인데, EDR은 이를 사용해 누가 누구에게 핸들을 여는지 확인하여 탐지한다. 루트킷에선 ObGetFilterVersion/내부 리스트를 스캔해서 EDR 드라이버의 콜백 구조 찾아서 해당 콜백 엔트리를 리스트에서 제거하거나 콜백 함수 포인터를 무효 주소로 바꿔 ObRegisterCallbacks 호출을 무효로 만들 수 있고, 또는 공격자의 커널 드라이버가 ObRegisterCallbacks를 먼저 호출해 이상 없는 핸들처럼 위장할 수 있다.
    
- Handle filtering 우회
    
    → Handle filtering이란 EDR이 lsass.exe, csrss.exe, winlogon.exe 등에 고위 권한의 핸들을 여는 프로세스를 감시/차단하는 것을 말한다. 이것을 우회하는 방법은 ObRegisterCallbacks 조작, 핸들 요청 변조, 요청 프로세스를 정상 프로세스로 위장하는 방법 등이 있다.
    
- Kernel callback unregistration
    
    → 커널에서 자주 쓰이는 콜백들 `PsSetCreateProcessNotifyRoutine(Ex)`, `CmRegisterCallbackEx`등 보안 제품/EDR/안티루트킷 드라이버는 “커널에서 특정 이벤트가 발생했을 때 알려줘”라는 훅 포인트가 존재하는데, 이 콜백들이 더이상 호출되지 않도록 한다. 커널 내부에는 콜백 리스트가 관리되는데, 이러한 리스트를 순회하며 특정 드라이버 주소 범위 안에 있는 콜백만 골라 제거하거나, Callback 포인터를 NULL로 바꾸는 등의 방법으로 콜백을 해제한다.
    

등이 있다.

## 결론

버퍼 오버플로우 등 일부 전통적 공격 기법은 보안 기능 발전으로 인해 점차 사라지고 있지만,

루트킷은 운영체제 개발 단계부터, 드라이버 서명 단계, 공급망, 시스템 배포 과정 등 **어디에서든 끼어들 수 있어 사라지지 않을 것이다**. 특히 최근에는 BYOVD, UEFI rootkit, EDR 우회 루트킷 등 과거보다 훨씬 더 은밀하고 분석이 어려운 형태로 진화하고 있다.